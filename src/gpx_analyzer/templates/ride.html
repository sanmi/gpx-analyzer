
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>{% if route_name %}{{ route_name }} | {% endif %}Ride Details</title>

    <!-- PWA meta tags -->
    <meta name="theme-color" content="#FF6B35">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="GPX Analyzer">
    <link rel="manifest" href="/manifest.json">
    <link rel="apple-touch-icon" href="{{ url_for('static', filename='icons/apple-touch-icon.png') }}">

    <link rel="stylesheet" href="{{ url_for('static', filename='css/ride.css') }}">
    {% if umami_website_id %}
    <script defer src="{{ umami_script_url }}" data-website-id="{{ umami_website_id }}"></script>
    {% endif %}
    <script defer src="{{ url_for('static', filename='js/sw-register.js') }}"></script>
    <script defer src="{{ url_for('static', filename='js/offline-storage.js') }}"></script>
    <script defer src="{{ url_for('static', filename='js/profile-renderer.js') }}"></script>
</head>
<body>
    <div class="header-section">
        <div class="logo-container">
            <svg class="logo" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                <defs>
                    <linearGradient id="mountainGrad" x1="0%" y1="0%" x2="100%" y2="100%">
                        <stop offset="0%" style="stop-color:#FF6B35"/>
                        <stop offset="100%" style="stop-color:#F7931E"/>
                    </linearGradient>
                </defs>
                <path d="M0 85 L25 45 L40 60 L60 30 L80 50 L100 85 Z" fill="url(#mountainGrad)"/>
                <path d="M60 30 L67 42 L53 42 Z" fill="white" opacity="0.85"/>
                <path d="M25 45 L30 52 L20 52 Z" fill="white" opacity="0.7"/>
                <g transform="translate(18, 50) rotate(-20) scale(1.5)">
                    <circle cx="0" cy="14" r="7" fill="none" stroke="#2D3047" stroke-width="1.5"/>
                    <circle cx="22" cy="14" r="7" fill="none" stroke="#2D3047" stroke-width="1.5"/>
                    <path d="M0 14 L8 6 L18 6 L22 14 M8 6 L11 14 L18 6 M11 14 L0 14"
                          fill="none" stroke="#2D3047" stroke-width="1.5" stroke-linejoin="round"/>
                    <line x1="8" y1="6" x2="7" y2="3" stroke="#2D3047" stroke-width="1.5"/>
                    <line x1="7" y1="3" x2="14" y2="-1" stroke="#2D3047" stroke-width="2" stroke-linecap="round"/>
                    <circle cx="16" cy="-2" r="2.5" fill="#2D3047"/>
                    <line x1="12" y1="-1" x2="18" y2="5" stroke="#2D3047" stroke-width="1.5" stroke-linecap="round"/>
                </g>
            </svg>
            <h1>Reality Check my Route</h1>
        </div>
        <p class="tagline">Climb Details</p>
        <a href="/" class="back-link" id="backLink">&larr; Back to Analysis</a>
    </div>

    <div class="summary-card">
        <div class="route-name">{{ route_name or "Route" }}</div>
        <div class="summary-grid">
            <div class="summary-item">
                <div class="summary-value">{{ time_str }}</div>
                <div class="summary-label">Est. Time</div>
            </div>
            <div class="summary-item">
                <div class="summary-value">{{ "%.0f"|format(work_kj) }} kJ</div>
                <div class="summary-label">Work</div>
            </div>
            <div class="summary-item">
                <div class="summary-value" id="summaryDistance" data-km="{{ distance_km }}">{{ "%.1f"|format(distance_km) }} km</div>
                <div class="summary-label">Distance</div>
            </div>
            <div class="summary-item">
                <div class="summary-value" id="summaryElevation" data-m="{{ elevation_m }}">{{ "%.0f"|format(elevation_m) }} m</div>
                <div class="summary-label">Elevation</div>
            </div>
        </div>
    </div>

    <div class="elevation-section">
        <div class="profile-header">
            <div class="section-title">Elevation Profile</div>
            <div class="profile-toggles">
                <div class="profile-toggle">
                    <input type="checkbox" id="overlay_speed" onchange="toggleOverlay('speed')">
                    <label for="overlay_speed">Speed</label>
                </div>
                <div class="profile-toggle">
                    <input type="checkbox" id="overlay_grade" onchange="toggleOverlay('grade')">
                    <label for="overlay_grade">Grade</label>
                </div>
                <div class="profile-toggle">
                    <input type="checkbox" id="overlay_gravel" onchange="toggleOverlay('gravel')">
                    <label for="overlay_gravel">Unpaved</label>
                </div>
                <div class="profile-toggle">
                    <input type="checkbox" id="imperial" {{ 'checked' if imperial else '' }} onchange="toggleImperial()">
                    <label for="imperial">Imperial</label>
                </div>
            </div>
        </div>
        <div class="main-profile-container" id="elevationContainer"
             data-base-profile-url="/elevation-profile?url={{ url|urlencode }}&climbing_power={{ climbing_power }}&flat_power={{ flat_power }}&mass={{ mass }}&headwind={{ headwind }}&smoothing={{ smoothing }}"
             data-base-data-url="/elevation-profile-data?url={{ url|urlencode }}&climbing_power={{ climbing_power }}&flat_power={{ flat_power }}&mass={{ mass }}&headwind={{ headwind }}&smoothing={{ smoothing }}">
            <div class="elevation-loading" id="elevationLoading">
                <div class="elevation-spinner"></div>
            </div>
            <canvas id="elevationCanvas" class="elevation-canvas"></canvas>
            <div class="elevation-tooltip" id="elevationTooltip"></div>
            <div class="zoom-out-link" id="zoomOutLink" style="display: none;"><a href="#" onclick="return false;">Zoom Out</a></div>
        </div>
    </div>

    <div class="elevation-section">
        <div class="section-title">Climb Detection</div>
        <div class="climb-profile-container" id="climbProfileContainer">
            <div class="elevation-loading" id="climbLoading">
                <div class="elevation-spinner"></div>
            </div>
            <canvas id="climbCanvas" class="elevation-canvas"></canvas>
            <div class="elevation-tooltip" id="climbTooltip"></div>
        </div>
        <div class="sensitivity-control">
            <div class="sensitivity-label">
                <span>High Sensitivity</span>
                <span>Low Sensitivity</span>
            </div>
            <input type="range" class="sensitivity-slider" id="sensitivitySlider"
                   min="0" max="100" step="10" value="{{ sensitivity }}"
                   aria-label="Climb detection sensitivity">
        </div>
    </div>

    <div class="climb-section">
        <div class="section-title">
            Detected Climbs
            <span class="climb-count" id="climbCount">({{ climbs|length }})</span>
        </div>
        <div class="climb-list" id="climbList">
            {% if climbs %}
                {% for climb in climbs %}
                <div class="climb-row">
                    <div class="climb-number">{{ climb.climb_id }}</div>
                    <div class="climb-details">
                        <div class="climb-name">{{ climb.label }}</div>
                        <div class="climb-metrics">
                            <div class="climb-metric">
                                <span class="metric-label">Distance</span>
                                <span class="metric-value">{% if imperial %}{{ "%.1f"|format(climb.distance_m / 1000 * 0.621371) }} mi{% else %}{{ "%.1f"|format(climb.distance_m / 1000) }} km{% endif %}</span>
                            </div>
                            <div class="climb-metric">
                                <span class="metric-label">Gain</span>
                                <span class="metric-value">{% if imperial %}{{ "%.0f"|format(climb.elevation_gain * 3.28084) }} ft{% else %}{{ "%.0f"|format(climb.elevation_gain) }} m{% endif %}</span>
                            </div>
                            <div class="climb-metric">
                                <span class="metric-label">Avg Grade</span>
                                <span class="metric-value">{{ "%.1f"|format(climb.avg_grade) }}%</span>
                            </div>
                            <div class="climb-metric">
                                <span class="metric-label">Max Grade</span>
                                <span class="metric-value">{{ "%.1f"|format(climb.max_grade) }}%</span>
                            </div>
                            <div class="climb-metric">
                                <span class="metric-label">Duration</span>
                                <span class="metric-value">{% if climb.duration_seconds >= 3600 %}{{ (climb.duration_seconds // 3600)|int }}h {{ ((climb.duration_seconds % 3600) // 60)|int }}m{% else %}{{ "%.0f"|format(climb.duration_seconds / 60) }} min{% endif %}</span>
                            </div>
                            <div class="climb-metric">
                                <span class="metric-label">Work</span>
                                <span class="metric-value">{{ "%.0f"|format(climb.work_kj) }} kJ</span>
                            </div>
                            <div class="climb-metric">
                                <span class="metric-label">Avg Power</span>
                                <span class="metric-value">{{ "%.0f"|format(climb.avg_power) }} W</span>
                            </div>
                            <div class="climb-metric">
                                <span class="metric-label">Avg Speed</span>
                                <span class="metric-value">{% if imperial %}{{ "%.1f"|format(climb.avg_speed_kmh * 0.621371) }} mph{% else %}{{ "%.1f"|format(climb.avg_speed_kmh) }} km/h{% endif %}</span>
                            </div>
                        </div>
                    </div>
                </div>
                {% endfor %}
            {% else %}
                <div class="no-climbs">No significant climbs detected</div>
            {% endif %}
        </div>
    </div>

    <script>
        const routeUrl = "{{ url }}";
        const baseParams = "climbing_power={{ climbing_power }}&flat_power={{ flat_power }}&mass={{ mass }}&headwind={{ headwind }}&smoothing={{ smoothing }}";

        // Climb detection
        const slider = document.getElementById('sensitivitySlider');
        const climbCanvas = document.getElementById('climbCanvas');
        const climbProfileContainer = document.getElementById('climbProfileContainer');
        const climbList = document.getElementById('climbList');
        const climbCount = document.getElementById('climbCount');
        let debounceTimer = null;
        let resizeTimer = null;
        let lastAspectRatio = null;
        let climbRenderer = null;

        // Calculate aspect ratio based on container width
        function getAspectRatio() {
            const container = climbProfileContainer || document.getElementById('elevationContainer');
            if (!container) return 1;
            const width = container.offsetWidth;
            if (width < 500) return 1;
            if (width < 800) return 2;
            return Math.min(3.5, width / 250);
        }

        function formatClimbDuration(seconds) {
            const totalMins = Math.floor(seconds / 60);
            if (totalMins >= 60) {
                const hours = Math.floor(totalMins / 60);
                const mins = totalMins % 60;
                return hours + 'h ' + mins + 'm';
            }
            return totalMins + ' min';
        }

        function isImperial() {
            return document.getElementById('imperial')?.checked || false;
        }

        function formatDistance(km) {
            if (isImperial()) return (km * 0.621371).toFixed(1) + ' mi';
            return km.toFixed(1) + ' km';
        }

        function formatElevation(m) {
            if (isImperial()) return Math.round(m * 3.28084) + ' ft';
            return Math.round(m) + ' m';
        }

        function formatSpeed(kmh) {
            if (isImperial()) return (kmh * 0.621371).toFixed(1) + ' mph';
            return kmh.toFixed(1) + ' km/h';
        }

        function renderClimbTable(climbs) {
            if (climbs.length === 0) {
                climbList.innerHTML = '<div class="no-climbs">No significant climbs detected</div>';
                climbCount.textContent = '(0)';
                return;
            }
            climbCount.textContent = '(' + climbs.length + ')';
            let html = '';
            climbs.forEach(climb => {
                html += `<div class="climb-row">
                    <div class="climb-number">${climb.climb_id}</div>
                    <div class="climb-details">
                        <div class="climb-name">${climb.label}</div>
                        <div class="climb-metrics">
                            <div class="climb-metric"><span class="metric-label">Distance</span><span class="metric-value">${formatDistance(climb.distance_m / 1000)}</span></div>
                            <div class="climb-metric"><span class="metric-label">Gain</span><span class="metric-value">${formatElevation(climb.elevation_gain)}</span></div>
                            <div class="climb-metric"><span class="metric-label">Avg Grade</span><span class="metric-value">${climb.avg_grade.toFixed(1)}%</span></div>
                            <div class="climb-metric"><span class="metric-label">Max Grade</span><span class="metric-value">${climb.max_grade.toFixed(1)}%</span></div>
                            <div class="climb-metric"><span class="metric-label">Duration</span><span class="metric-value">${formatClimbDuration(climb.duration_seconds)}</span></div>
                            <div class="climb-metric"><span class="metric-label">Work</span><span class="metric-value">${climb.work_kj.toFixed(0)} kJ</span></div>
                            <div class="climb-metric"><span class="metric-label">Avg Power</span><span class="metric-value">${climb.avg_power.toFixed(0)} W</span></div>
                            <div class="climb-metric"><span class="metric-label">Avg Speed</span><span class="metric-value">${formatSpeed(climb.avg_speed_kmh)}</span></div>
                        </div>
                    </div>
                </div>`;
            });
            climbList.innerHTML = html;
        }

        function updateClimbs(forceRefresh = false) {
            clearTimeout(debounceTimer);
            debounceTimer = setTimeout(() => {
                const sensitivity = slider.value;
                const climbLoading = document.getElementById('climbLoading');
                const climbTooltip = document.getElementById('climbTooltip');

                // Fetch climb data and elevation profile data
                Promise.all([
                    fetch(`/api/detect-climbs?url=${encodeURIComponent(routeUrl)}&${baseParams}&sensitivity=${sensitivity}`).then(r => r.json()),
                    fetch(`/elevation-profile-data?url=${encodeURIComponent(routeUrl)}&${baseParams}`).then(r => r.json())
                ])
                .then(([climbData, profileData]) => {
                    // Render climb table
                    renderClimbTable(climbData.climbs);

                    // Convert climbs to climb regions for rendering
                    const climbRegions = climbData.climbs.map(climb => ({
                        start_time: climb.start_time_hours,
                        end_time: climb.end_time_hours,
                        climb_id: climb.climb_id,
                        label: climb.label
                    }));

                    // Create or update climb canvas renderer
                    if (climbLoading) climbLoading.classList.add('hidden');

                    const options = {
                        imperial: isImperial(),
                        showSpeedOverlay: false,
                        showGradeOverlay: false,
                        showGravel: false,
                        tunnelRanges: profileData.tunnel_ranges || [],
                        unpavedRanges: profileData.unpaved_ranges || []
                    };

                    // Add climb regions to profile data
                    profileData.climb_regions = climbRegions;

                    if (climbRenderer) {
                        // Update existing renderer with new climb regions
                        climbRenderer.climbRegions = climbRegions;
                        climbRenderer.render();
                    } else {
                        // Create new renderer
                        climbRenderer = new ElevationProfileRenderer(climbCanvas, profileData, options);

                        // Wire up hover callback for tooltip
                        climbRenderer.onHover = function(dataPoint, x, y) {
                            const imp = isImperial();
                            const elevUnit = imp ? 'ft' : 'm';
                            const elevVal = imp ? dataPoint.elevation * 3.28084 : dataPoint.elevation;
                            climbTooltip.innerHTML = '<div class="grade">' + formatGrade(dataPoint.grade) + '</div>' +
                                                    '<div class="elev">' + Math.round(elevVal) + ' ' + elevUnit + ' | ' + formatTime(dataPoint.time) + '</div>';
                            climbTooltip.style.left = x + 'px';
                            climbTooltip.style.bottom = '60px';
                            climbTooltip.classList.add('visible');
                        };

                        // Wire up selection callback
                        climbRenderer.onSelect = function(stats, selection) {
                            showSelectionPopup(stats, selection, climbRenderer, climbProfileContainer);
                        };

                        climbRenderer.init();

                        // Hide tooltip when mouse leaves canvas
                        climbCanvas.addEventListener('mouseleave', () => {
                            climbTooltip.classList.remove('visible');
                        });
                    }
                })
                .catch(err => {
                    console.error('Error fetching climb data:', err);
                    if (climbLoading) climbLoading.classList.add('hidden');
                });
            }, 300);
        }
        slider.addEventListener('input', () => updateClimbs(true));

        // Format duration for popup
        function formatDuration(hours) {
            const totalMin = Math.round(hours * 60);
            if (totalMin < 60) return totalMin + 'min';
            return Math.floor(totalMin / 60) + 'h ' + (totalMin % 60).toString().padStart(2, '0') + 'm';
        }

        // Format time
        function formatTime(hours) {
            const h = Math.floor(hours);
            const m = Math.floor((hours - h) * 60);
            return h + 'h ' + m.toString().padStart(2, '0') + 'm';
        }

        // Format grade
        function formatGrade(g) {
            if (g === null || g === undefined) return 'Stopped';
            return (g >= 0 ? '+' : '') + g.toFixed(1) + '%';
        }

        // Selection popup state
        let selectionPopup = null;
        let currentSelection = null;
        let selectionJustCreated = false;

        function updateZoomOutLink(renderer) {
            const zoomOutLink = document.getElementById('zoomOutLink');
            if (!zoomOutLink) return;
            const isZoomed = renderer.viewRange.start > 0 || renderer.viewRange.end < 1;
            zoomOutLink.style.display = isZoomed ? 'block' : 'none';
            if (isZoomed) {
                zoomOutLink.querySelector('a').onclick = function(e) {
                    e.preventDefault();
                    renderer.resetZoom();
                    updateZoomOutLink(renderer);
                };
            }
        }

        function showSelectionPopup(stats, selection, renderer, container) {
            hideSelectionPopup();
            currentSelection = { stats, selection, renderer, container };
            // Set flag to prevent immediate dismissal by click handler
            selectionJustCreated = true;
            setTimeout(() => { selectionJustCreated = false; }, 0);

            const imp = isImperial();
            const distVal = imp ? (stats.distance / 1000 * 0.621371) : (stats.distance / 1000);
            const distUnit = imp ? 'mi' : 'km';
            const elevGainVal = imp ? (stats.elevGain * 3.28084) : stats.elevGain;
            const elevLossVal = imp ? (stats.elevLoss * 3.28084) : stats.elevLoss;
            const elevUnit = imp ? 'ft' : 'm';
            const speedVal = stats.avgSpeed > 0 ? (imp ? stats.avgSpeed * 0.621371 : stats.avgSpeed) : null;
            const speedUnit = imp ? 'mph' : 'km/h';
            const isZoomed = renderer.viewRange.start > 0 || renderer.viewRange.end < 1;

            selectionPopup = document.createElement('div');
            selectionPopup.className = 'elevation-selection-popup';
            selectionPopup.style.display = 'block';

            let html = '<span class="selection-close">&times;</span>';
            html += '<div class="selection-stat"><span class="stat-label">Duration</span><span class="stat-value">' + formatDuration(stats.duration) + '</span></div>';
            html += '<div class="selection-stat"><span class="stat-label">Distance</span><span class="stat-value">' + distVal.toFixed(1) + ' ' + distUnit + '</span></div>';
            html += '<div class="selection-stat"><span class="stat-label">Elev Gain</span><span class="stat-value">+' + Math.round(elevGainVal) + ' ' + elevUnit + '</span></div>';
            html += '<div class="selection-stat"><span class="stat-label">Elev Loss</span><span class="stat-value">' + Math.round(elevLossVal) + ' ' + elevUnit + '</span></div>';
            if (speedVal !== null) html += '<div class="selection-stat"><span class="stat-label">Avg Speed</span><span class="stat-value">' + speedVal.toFixed(1) + ' ' + speedUnit + '</span></div>';
            if (stats.work > 0) html += '<div class="selection-stat"><span class="stat-label">Work</span><span class="stat-value">' + stats.work.toFixed(1) + ' kJ</span></div>';
            html += '<div class="selection-zoom-btn">' + (isZoomed ? 'Zoom Out' : 'Zoom In') + '</div>';

            selectionPopup.innerHTML = html;

            // Position popup at center of selection
            const centerNorm = (selection.start + selection.end) / 2;
            const centerX = renderer._normToCanvasX(centerNorm);
            selectionPopup.style.left = centerX + 'px';
            selectionPopup.style.bottom = '70px';

            container.appendChild(selectionPopup);

            // Wire up close button
            selectionPopup.querySelector('.selection-close').addEventListener('click', (e) => {
                e.stopPropagation();
                clearSelectionAndPopup(renderer);
            });

            // Wire up zoom button
            selectionPopup.querySelector('.selection-zoom-btn').addEventListener('click', (e) => {
                e.stopPropagation();
                if (isZoomed) {
                    renderer.resetZoom();
                } else {
                    renderer.zoomToSelection();
                }
                hideSelectionPopup();
                updateZoomOutLink(renderer);
            });
        }

        function hideSelectionPopup() {
            if (selectionPopup && selectionPopup.parentNode) {
                selectionPopup.parentNode.removeChild(selectionPopup);
            }
            selectionPopup = null;
        }

        function clearSelectionAndPopup(renderer) {
            hideSelectionPopup();
            if (renderer) {
                renderer.selection = null;
                renderer.render();
            }
            currentSelection = null;
        }

        // Click outside handler for dismissing selection popup
        document.addEventListener('click', (e) => {
            // Skip if selection was just created (prevents immediate dismissal after mouseup)
            if (selectionJustCreated) return;
            if (!currentSelection) return;
            // Check if click is inside popup
            if (selectionPopup && selectionPopup.contains(e.target)) return;
            // Click anywhere else (including on canvas) - dismiss popup and selection
            clearSelectionAndPopup(currentSelection.renderer);
        });

        // Setup main elevation profile with Canvas renderer
        function setupElevationProfile(containerId, canvasId, tooltipId, dataUrl, maxXlimHours) {
            const container = document.getElementById(containerId);
            const canvas = document.getElementById(canvasId);
            const tooltip = document.getElementById(tooltipId);
            const loading = document.getElementById('elevationLoading');
            if (!container || !canvas || !tooltip) return;

            // Show loading state
            if (loading) loading.classList.remove('hidden');

            fetch(dataUrl)
                .then(r => {
                    if (!r.ok) throw new Error('HTTP ' + r.status);
                    return r.json();
                })
                .then(data => {
                    if (loading) loading.classList.add('hidden');

                    // Build options based on current toggle states (use correct property names)
                    const options = {
                        imperial: isImperial(),
                        showSpeedOverlay: document.getElementById('overlay_speed')?.checked || false,
                        showGradeOverlay: document.getElementById('overlay_grade')?.checked || false,
                        showGravel: document.getElementById('overlay_gravel')?.checked || false,
                        tunnelRanges: data.tunnel_ranges || [],
                        unpavedRanges: data.unpaved_ranges || []
                    };

                    // Create renderer instance
                    const renderer = new ElevationProfileRenderer(canvas, data, options);

                    // Wire up hover callback for tooltip
                    renderer.onHover = function(dataPoint, x, y) {
                        const imp = isImperial();
                        const elevUnit = imp ? 'ft' : 'm';
                        const elevVal = imp ? dataPoint.elevation * 3.28084 : dataPoint.elevation;
                        let speedText = '';
                        if (dataPoint.speed !== null && dataPoint.speed !== undefined) {
                            const speedUnit = imp ? 'mph' : 'km/h';
                            const speedVal = imp ? dataPoint.speed * 0.621371 : dataPoint.speed;
                            speedText = ' | ' + speedVal.toFixed(1) + ' ' + speedUnit;
                        }

                        tooltip.innerHTML = '<div class="grade">' + formatGrade(dataPoint.grade) + '</div>' +
                                           '<div class="elev">' + Math.round(elevVal) + ' ' + elevUnit + speedText + ' | ' + formatTime(dataPoint.time) + '</div>';
                        tooltip.style.left = x + 'px';
                        tooltip.style.bottom = '60px';
                        tooltip.classList.add('visible');
                    };

                    // Wire up selection callback for zoom popup
                    renderer.onSelect = function(stats, selection) {
                        showSelectionPopup(stats, selection, renderer, container);
                    };

                    renderer.init();

                    // Hide tooltip when mouse leaves canvas
                    canvas.addEventListener('mouseleave', () => {
                        tooltip.classList.remove('visible');
                    });

                    // Store renderer reference on container for overlay toggle updates
                    container._renderer = renderer;
                    container._profileData = data;

                    // Method for updating renderer options (used by toggleOverlay)
                    container._updateRendererOptions = function(newOptions) {
                        // Update direct properties on renderer
                        if ('showSpeedOverlay' in newOptions) renderer.showSpeedOverlay = newOptions.showSpeedOverlay;
                        if ('showGradeOverlay' in newOptions) renderer.showGradeOverlay = newOptions.showGradeOverlay;
                        if ('showGravel' in newOptions) renderer.showGravel = newOptions.showGravel;
                        if ('imperial' in newOptions) renderer.imperial = newOptions.imperial;
                        renderer.render();
                    };
                })
                .catch(err => {
                    console.error('Profile data fetch error:', err);
                    if (loading) loading.classList.add('hidden');
                });
        }

        // Handle window resize and orientation change
        function handleResize() {
            clearTimeout(resizeTimer);
            resizeTimer = setTimeout(() => {
                // Re-render both canvases on resize
                const container = document.getElementById('elevationContainer');
                if (container?._renderer) {
                    container._renderer.init();
                }
                if (climbRenderer) {
                    climbRenderer.init();
                }
            }, 250);
        }
        window.addEventListener('resize', handleResize);
        window.addEventListener('orientationchange', () => setTimeout(handleResize, 100));

        // Handle offline page load using cached data from IndexedDB
        async function handleOfflinePageLoad() {
            if (navigator.onLine) return false;

            // Update route name from URL param (cached page may have wrong name)
            const urlParams = new URLSearchParams(window.location.search);
            const routeNameFromUrl = urlParams.get('route_name');
            if (routeNameFromUrl) {
                const routeNameEl = document.querySelector('.route-name');
                if (routeNameEl) routeNameEl.textContent = routeNameFromUrl;
                document.title = routeNameFromUrl + ' | Ride Details';
            }

            // Try to load data from IndexedDB
            if (typeof offlineStorage === 'undefined') {
                console.log('[Ride] offlineStorage not available');
                return false;
            }

            try {
                await offlineStorage.init();

                // Get saved route metadata (includes the params it was saved with)
                const savedRoute = await offlineStorage.getSavedRoute(routeUrl);
                if (!savedRoute || !savedRoute.analysisParams) {
                    console.log('[Ride] Route not saved for offline use');
                    return false;
                }

                const params = savedRoute.analysisParams;

                // Get cached profile data
                const profileData = await offlineStorage.getProfileData(routeUrl, params);
                if (!profileData) {
                    console.log('[Ride] No cached profile data');
                    return false;
                }

                // Get cached climbs
                const climbs = await offlineStorage.getClimbs(routeUrl, params);

                // Hide loading spinners
                const elevationLoading = document.getElementById('elevationLoading');
                const climbLoading = document.getElementById('climbLoading');
                if (elevationLoading) elevationLoading.classList.add('hidden');
                if (climbLoading) climbLoading.classList.add('hidden');

                // Setup elevation profile with cached data
                setupElevationProfileOffline(profileData);

                // Render climbs with cached data
                if (climbs && climbs.length > 0) {
                    renderClimbTable(climbs);
                    setupClimbProfileOffline(profileData, climbs);
                }

                console.log('[Ride] Loaded from offline cache');
                return true;
            } catch (err) {
                console.error('[Ride] Offline load error:', err);
                return false;
            }
        }

        // Setup elevation profile with offline data (no fetch)
        function setupElevationProfileOffline(profileData) {
            const container = document.getElementById('elevationContainer');
            const canvas = document.getElementById('elevationCanvas');
            const tooltip = document.getElementById('elevationTooltip');
            if (!container || !canvas || !tooltip) return;

            const options = {
                imperial: isImperial(),
                showSpeedOverlay: document.getElementById('overlay_speed')?.checked || false,
                showGradeOverlay: document.getElementById('overlay_grade')?.checked || false,
                showGravel: document.getElementById('overlay_gravel')?.checked || false,
                tunnelRanges: profileData.tunnel_ranges || [],
                unpavedRanges: profileData.unpaved_ranges || []
            };

            const renderer = new ElevationProfileRenderer(canvas, profileData, options);

            renderer.onHover = function(dataPoint, x, y) {
                const imp = isImperial();
                const elevUnit = imp ? 'ft' : 'm';
                const elevVal = imp ? dataPoint.elevation * 3.28084 : dataPoint.elevation;
                let speedText = '';
                if (dataPoint.speed !== null && dataPoint.speed !== undefined) {
                    const speedUnit = imp ? 'mph' : 'km/h';
                    const speedVal = imp ? dataPoint.speed * 0.621371 : dataPoint.speed;
                    speedText = ' | ' + speedVal.toFixed(1) + ' ' + speedUnit;
                }
                tooltip.innerHTML = '<div class="grade">' + formatGrade(dataPoint.grade) + '</div>' +
                                   '<div class="elev">' + Math.round(elevVal) + ' ' + elevUnit + speedText + ' | ' + formatTime(dataPoint.time) + '</div>';
                tooltip.style.left = x + 'px';
                tooltip.style.bottom = '60px';
                tooltip.classList.add('visible');
            };

            renderer.onSelect = function(stats, selection) {
                showSelectionPopup(stats, selection, renderer, container);
            };

            renderer.init();

            canvas.addEventListener('mouseleave', () => {
                tooltip.classList.remove('visible');
            });

            container._renderer = renderer;
            container._profileData = profileData;

            container._updateRendererOptions = function(newOptions) {
                if ('showSpeedOverlay' in newOptions) renderer.showSpeedOverlay = newOptions.showSpeedOverlay;
                if ('showGradeOverlay' in newOptions) renderer.showGradeOverlay = newOptions.showGradeOverlay;
                if ('showGravel' in newOptions) renderer.showGravel = newOptions.showGravel;
                if ('imperial' in newOptions) renderer.imperial = newOptions.imperial;
                renderer.render();
            };
        }

        // Setup climb profile with offline data
        function setupClimbProfileOffline(profileData, climbs) {
            const climbTooltip = document.getElementById('climbTooltip');

            const climbRegions = climbs.map(climb => ({
                start_time: climb.start_time_hours,
                end_time: climb.end_time_hours,
                climb_id: climb.climb_id,
                label: climb.label
            }));

            profileData.climb_regions = climbRegions;

            const options = {
                imperial: isImperial(),
                showSpeedOverlay: false,
                showGradeOverlay: false,
                showGravel: false,
                tunnelRanges: profileData.tunnel_ranges || [],
                unpavedRanges: profileData.unpaved_ranges || []
            };

            climbRenderer = new ElevationProfileRenderer(climbCanvas, profileData, options);

            climbRenderer.onHover = function(dataPoint, x, y) {
                const imp = isImperial();
                const elevUnit = imp ? 'ft' : 'm';
                const elevVal = imp ? dataPoint.elevation * 3.28084 : dataPoint.elevation;
                climbTooltip.innerHTML = '<div class="grade">' + formatGrade(dataPoint.grade) + '</div>' +
                                        '<div class="elev">' + Math.round(elevVal) + ' ' + elevUnit + ' | ' + formatTime(dataPoint.time) + '</div>';
                climbTooltip.style.left = x + 'px';
                climbTooltip.style.bottom = '60px';
                climbTooltip.classList.add('visible');
            };

            climbRenderer.onSelect = function(stats, selection) {
                showSelectionPopup(stats, selection, climbRenderer, climbProfileContainer);
            };

            climbRenderer.init();

            climbCanvas.addEventListener('mouseleave', () => {
                climbTooltip.classList.remove('visible');
            });
        }

        // Initial load
        document.addEventListener('DOMContentLoaded', async () => {
            // Try offline first
            const loadedOffline = await handleOfflinePageLoad();

            // If offline load succeeded, skip online fetch
            if (loadedOffline) return;

            const container = document.getElementById('elevationContainer');
            const dataUrl = container?.getAttribute('data-base-data-url');
            if (dataUrl) {
                setupElevationProfile('elevationContainer', 'elevationCanvas', 'elevationTooltip', dataUrl, null);
            }
            updateClimbs(true);
        });

        // Save sensitivity to localStorage when changed
        slider.addEventListener('change', () => {
            try { localStorage.setItem('ride_sensitivity', slider.value); } catch (e) {}
        });

        // Overlay toggles - now uses Canvas renderer
        function toggleOverlay(type) {
            // Speed and grade are mutually exclusive (only one secondary Y-axis)
            if (type === 'speed' || type === 'grade') {
                const checkbox = document.getElementById('overlay_' + type);
                if (checkbox && checkbox.checked) {
                    const otherType = type === 'speed' ? 'grade' : 'speed';
                    const otherCheckbox = document.getElementById('overlay_' + otherType);
                    if (otherCheckbox && otherCheckbox.checked) {
                        otherCheckbox.checked = false;
                    }
                }
            }

            const container = document.getElementById('elevationContainer');
            if (container?._updateRendererOptions) {
                container._updateRendererOptions({
                    showSpeedOverlay: document.getElementById('overlay_speed')?.checked || false,
                    showGradeOverlay: document.getElementById('overlay_grade')?.checked || false,
                    showGravel: document.getElementById('overlay_gravel')?.checked || false
                });
            }

            // Save toggle states to localStorage
            try {
                localStorage.setItem('ride_show_speed', document.getElementById('overlay_speed')?.checked || false);
                localStorage.setItem('ride_show_grade', document.getElementById('overlay_grade')?.checked || false);
                localStorage.setItem('ride_show_gravel', document.getElementById('overlay_gravel')?.checked || false);
            } catch (e) {}
        }

        function updateSummaryUnits() {
            const distEl = document.getElementById('summaryDistance');
            const elevEl = document.getElementById('summaryElevation');
            if (distEl) {
                const km = parseFloat(distEl.dataset.km);
                distEl.textContent = formatDistance(km);
            }
            if (elevEl) {
                const m = parseFloat(elevEl.dataset.m);
                elevEl.textContent = formatElevation(m);
            }
        }

        function toggleImperial() {
            const imperial = isImperial();
            try { localStorage.setItem('ride_imperial', imperial); } catch (e) {}
            updateSummaryUnits();

            // Update Canvas renderer with new imperial setting
            const container = document.getElementById('elevationContainer');
            if (container?._updateRendererOptions) {
                container._updateRendererOptions({ imperial: imperial });
            }

            // Re-render climb table with new units
            updateClimbs();
        }
        // Update back link href with current settings (for iOS PWA compatibility)
        function updateBackLink() {
            let url = '/?url=' + encodeURIComponent(routeUrl) + '&' + baseParams;
            // Add settings from localStorage
            try {
                if (localStorage.getItem('overlay_speed') === 'true') url += '&overlay=speed';
                if (localStorage.getItem('overlay_grade') === 'true') url += '&overlay=grade';
                if (localStorage.getItem('overlay_gravel') === 'true') url += '&show_gravel=true';
                if (localStorage.getItem('ride_imperial') === 'true') url += '&imperial=1';
            } catch (e) {}
            const backLink = document.getElementById('backLink');
            if (backLink) backLink.href = url;
        }

        // Load saved settings from localStorage
        function initSavedSettings() {
            try {
                // Load speed toggle
                const savedSpeed = localStorage.getItem('ride_show_speed');
                const speedCb = document.getElementById('overlay_speed');
                if (savedSpeed === 'true' && speedCb) {
                    speedCb.checked = true;
                }
                // Load grade toggle
                const savedGrade = localStorage.getItem('ride_show_grade');
                const gradeCb = document.getElementById('overlay_grade');
                if (savedGrade === 'true' && gradeCb) {
                    gradeCb.checked = true;
                }
                // Enforce mutual exclusivity: if both speed and grade are checked, prefer speed
                if (speedCb && gradeCb && speedCb.checked && gradeCb.checked) {
                    gradeCb.checked = false;
                }
                // Load gravel toggle
                const savedGravel = localStorage.getItem('ride_show_gravel');
                if (savedGravel === 'true') {
                    const gravelCb = document.getElementById('overlay_gravel');
                    if (gravelCb) gravelCb.checked = true;
                }
                // Load imperial setting
                const savedImperial = localStorage.getItem('ride_imperial');
                const imperialCb = document.getElementById('imperial');
                if (savedImperial !== null && imperialCb) {
                    imperialCb.checked = savedImperial === 'true';
                }
                // Load sensitivity slider
                const savedSensitivity = localStorage.getItem('ride_sensitivity');
                if (savedSensitivity !== null) {
                    const sensitivityVal = parseInt(savedSensitivity, 10);
                    if (!isNaN(sensitivityVal) && sensitivityVal >= 0 && sensitivityVal <= 100) {
                        slider.value = sensitivityVal;
                    }
                }
                // Update units based on imperial setting
                updateSummaryUnits();
            } catch (e) {}
        }
        initSavedSettings();
        updateBackLink();
    </script>

    <div class="footer">
        <div class="footer-content">
            <div class="footer-links">
                <a href="https://github.com/sanmi/gpx-analyzer" target="_blank">Source Code</a>
                <a href="https://github.com/sanmi/gpx-analyzer/issues" target="_blank">Report a Bug</a>
            </div>
            <div class="footer-version">{{ version_date }} ({{ git_hash }})</div>
            <div class="footer-copyright">Â© 2025 Frank San Miguel</div>
        </div>
    </div>
    {% if umami_website_id and route_name %}
    <script>
        // Track ride page view with Umami (wait for script to load)
        window.addEventListener('load', function() {
            if (typeof umami !== 'undefined') {
                umami.track('ride-view', {
                    distance_km: {{ "%.1f"|format(distance_km) if distance_km else 0 }},
                    elevation_m: {{ "%.0f"|format(elevation_m) if elevation_m else 0 }},
                    climbs: {{ climbs|length if climbs else 0 }},
                    name: '{{ route_name|replace("'", "\\'") if route_name else "" }}'
                });
            }
        });
    </script>
    {% endif %}
</body>
</html>
