
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>{% if route_name %}{{ route_name }} | {% endif %}Ride Details</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/ride.css') }}">
    {% if umami_website_id %}
    <script defer src="{{ umami_script_url }}" data-website-id="{{ umami_website_id }}"></script>
    {% endif %}
</head>
<body>
    <div class="header-section">
        <div class="logo-container">
            <svg class="logo" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                <defs>
                    <linearGradient id="mountainGrad" x1="0%" y1="0%" x2="100%" y2="100%">
                        <stop offset="0%" style="stop-color:#FF6B35"/>
                        <stop offset="100%" style="stop-color:#F7931E"/>
                    </linearGradient>
                </defs>
                <path d="M0 85 L25 45 L40 60 L60 30 L80 50 L100 85 Z" fill="url(#mountainGrad)"/>
                <path d="M60 30 L67 42 L53 42 Z" fill="white" opacity="0.85"/>
                <path d="M25 45 L30 52 L20 52 Z" fill="white" opacity="0.7"/>
                <g transform="translate(18, 50) rotate(-20) scale(1.5)">
                    <circle cx="0" cy="14" r="7" fill="none" stroke="#2D3047" stroke-width="1.5"/>
                    <circle cx="22" cy="14" r="7" fill="none" stroke="#2D3047" stroke-width="1.5"/>
                    <path d="M0 14 L8 6 L18 6 L22 14 M8 6 L11 14 L18 6 M11 14 L0 14"
                          fill="none" stroke="#2D3047" stroke-width="1.5" stroke-linejoin="round"/>
                    <line x1="8" y1="6" x2="7" y2="3" stroke="#2D3047" stroke-width="1.5"/>
                    <line x1="7" y1="3" x2="14" y2="-1" stroke="#2D3047" stroke-width="2" stroke-linecap="round"/>
                    <circle cx="16" cy="-2" r="2.5" fill="#2D3047"/>
                    <line x1="12" y1="-1" x2="18" y2="5" stroke="#2D3047" stroke-width="1.5" stroke-linecap="round"/>
                </g>
            </svg>
            <h1>Reality Check my Route</h1>
        </div>
        <p class="tagline">Climb Details</p>
        <a href="#" class="back-link" id="backLink" onclick="goBack(); return false;">&larr; Back to Analysis</a>
    </div>

    <div class="summary-card">
        <div class="route-name">{{ route_name or "Route" }}</div>
        <div class="summary-grid">
            <div class="summary-item">
                <div class="summary-value">{{ time_str }}</div>
                <div class="summary-label">Est. Time</div>
            </div>
            <div class="summary-item">
                <div class="summary-value">{{ "%.0f"|format(work_kj) }} kJ</div>
                <div class="summary-label">Work</div>
            </div>
            <div class="summary-item">
                <div class="summary-value" id="summaryDistance" data-km="{{ distance_km }}">{{ "%.1f"|format(distance_km) }} km</div>
                <div class="summary-label">Distance</div>
            </div>
            <div class="summary-item">
                <div class="summary-value" id="summaryElevation" data-m="{{ elevation_m }}">{{ "%.0f"|format(elevation_m) }} m</div>
                <div class="summary-label">Elevation</div>
            </div>
        </div>
    </div>

    <div class="elevation-section">
        <div class="profile-header">
            <div class="section-title">Elevation Profile</div>
            <div class="profile-toggles">
                <div class="profile-toggle">
                    <input type="checkbox" id="overlay_speed" onchange="toggleOverlay('speed')">
                    <label for="overlay_speed">Speed</label>
                </div>
                <div class="profile-toggle">
                    <input type="checkbox" id="overlay_grade" onchange="toggleOverlay('grade')">
                    <label for="overlay_grade">Grade</label>
                </div>
                <div class="profile-toggle">
                    <input type="checkbox" id="overlay_gravel" onchange="toggleOverlay('gravel')">
                    <label for="overlay_gravel">Unpaved</label>
                </div>
                <div class="profile-toggle">
                    <input type="checkbox" id="imperial" {{ 'checked' if imperial else '' }} onchange="toggleImperial()">
                    <label for="imperial">Imperial</label>
                </div>
            </div>
        </div>
        <div class="main-profile-container" id="elevationContainer"
             data-base-profile-url="/elevation-profile?url={{ url|urlencode }}&climbing_power={{ climbing_power }}&flat_power={{ flat_power }}&mass={{ mass }}&headwind={{ headwind }}&smoothing={{ smoothing }}"
             data-base-data-url="/elevation-profile-data?url={{ url|urlencode }}&climbing_power={{ climbing_power }}&flat_power={{ flat_power }}&mass={{ mass }}&headwind={{ headwind }}&smoothing={{ smoothing }}">
            <div class="elevation-loading" id="elevationLoading">
                <div class="elevation-spinner"></div>
            </div>
            <img src="" alt="Elevation Profile" id="elevationImg" class="loading">
            <div class="elevation-cursor" id="elevationCursor"></div>
            <div class="elevation-tooltip" id="elevationTooltip">
                <div class="grade">--</div>
                <div class="elev">--</div>
            </div>
            <div class="elevation-selection" id="elevationSelection"></div>
            <div class="elevation-selection-popup" id="elevationSelectionPopup" style="display: none;"></div>
            <div class="zoom-out-link" id="zoomOutLink" style="display: none;"><a href="#" onclick="return false;">Zoom Out</a></div>
        </div>
    </div>

    <div class="elevation-section">
        <div class="section-title">Climb Detection</div>
        <div class="climb-profile-container" id="climbProfileContainer">
            <div class="elevation-loading" id="climbLoading">
                <div class="elevation-spinner"></div>
            </div>
            <img id="climbProfileImage" src="" alt="Climb Profile" class="loading">
        </div>
        <div class="sensitivity-control">
            <div class="sensitivity-label">
                <span>High Sensitivity</span>
                <span>Low Sensitivity</span>
            </div>
            <input type="range" class="sensitivity-slider" id="sensitivitySlider"
                   min="0" max="100" step="10" value="{{ sensitivity }}"
                   aria-label="Climb detection sensitivity">
        </div>
    </div>

    <div class="climb-section">
        <div class="section-title">
            Detected Climbs
            <span class="climb-count" id="climbCount">({{ climbs|length }})</span>
        </div>
        <div class="climb-list" id="climbList">
            {% if climbs %}
                {% for climb in climbs %}
                <div class="climb-row">
                    <div class="climb-number">{{ climb.climb_id }}</div>
                    <div class="climb-details">
                        <div class="climb-name">{{ climb.label }}</div>
                        <div class="climb-metrics">
                            <div class="climb-metric">
                                <span class="metric-label">Distance</span>
                                <span class="metric-value">{% if imperial %}{{ "%.1f"|format(climb.distance_m / 1000 * 0.621371) }} mi{% else %}{{ "%.1f"|format(climb.distance_m / 1000) }} km{% endif %}</span>
                            </div>
                            <div class="climb-metric">
                                <span class="metric-label">Gain</span>
                                <span class="metric-value">{% if imperial %}{{ "%.0f"|format(climb.elevation_gain * 3.28084) }} ft{% else %}{{ "%.0f"|format(climb.elevation_gain) }} m{% endif %}</span>
                            </div>
                            <div class="climb-metric">
                                <span class="metric-label">Avg Grade</span>
                                <span class="metric-value">{{ "%.1f"|format(climb.avg_grade) }}%</span>
                            </div>
                            <div class="climb-metric">
                                <span class="metric-label">Max Grade</span>
                                <span class="metric-value">{{ "%.1f"|format(climb.max_grade) }}%</span>
                            </div>
                            <div class="climb-metric">
                                <span class="metric-label">Duration</span>
                                <span class="metric-value">{% if climb.duration_seconds >= 3600 %}{{ (climb.duration_seconds // 3600)|int }}h {{ ((climb.duration_seconds % 3600) // 60)|int }}m{% else %}{{ "%.0f"|format(climb.duration_seconds / 60) }} min{% endif %}</span>
                            </div>
                            <div class="climb-metric">
                                <span class="metric-label">Work</span>
                                <span class="metric-value">{{ "%.0f"|format(climb.work_kj) }} kJ</span>
                            </div>
                            <div class="climb-metric">
                                <span class="metric-label">Avg Power</span>
                                <span class="metric-value">{{ "%.0f"|format(climb.avg_power) }} W</span>
                            </div>
                            <div class="climb-metric">
                                <span class="metric-label">Avg Speed</span>
                                <span class="metric-value">{% if imperial %}{{ "%.1f"|format(climb.avg_speed_kmh * 0.621371) }} mph{% else %}{{ "%.1f"|format(climb.avg_speed_kmh) }} km/h{% endif %}</span>
                            </div>
                        </div>
                    </div>
                </div>
                {% endfor %}
            {% else %}
                <div class="no-climbs">No significant climbs detected</div>
            {% endif %}
        </div>
    </div>

    <script>
        const routeUrl = "{{ url }}";
        const baseParams = "climbing_power={{ climbing_power }}&flat_power={{ flat_power }}&mass={{ mass }}&headwind={{ headwind }}&smoothing={{ smoothing }}";

        // Climb detection
        const slider = document.getElementById('sensitivitySlider');
        const climbProfileImage = document.getElementById('climbProfileImage');
        const climbProfileContainer = document.getElementById('climbProfileContainer');
        const climbList = document.getElementById('climbList');
        const climbCount = document.getElementById('climbCount');
        let debounceTimer = null;
        let resizeTimer = null;
        let lastAspectRatio = null;

        // Calculate aspect ratio based on container width
        function getAspectRatio() {
            const container = climbProfileContainer || document.getElementById('elevationContainer');
            if (!container) return 1;
            const width = container.offsetWidth;
            // Mobile portrait: square (1:1)
            if (width < 500) return 1;
            // Mobile landscape / tablet: 2:1
            if (width < 800) return 2;
            // Desktop: wider ratio based on actual width
            // Height stays constant, so aspect = width / fixed_height
            // Use width / 300 to get a good ratio (300px is a reasonable chart height)
            return Math.min(3.5, width / 250);
        }

        function formatClimbDuration(seconds) {
            const totalMins = Math.floor(seconds / 60);
            if (totalMins >= 60) {
                const hours = Math.floor(totalMins / 60);
                const mins = totalMins % 60;
                return hours + 'h ' + mins + 'm';
            }
            return totalMins + ' min';
        }

        function isImperial() {
            return document.getElementById('imperial')?.checked || false;
        }

        function formatDistance(km) {
            if (isImperial()) return (km * 0.621371).toFixed(1) + ' mi';
            return km.toFixed(1) + ' km';
        }

        function formatElevation(m) {
            if (isImperial()) return Math.round(m * 3.28084) + ' ft';
            return Math.round(m) + ' m';
        }

        function formatSpeed(kmh) {
            if (isImperial()) return (kmh * 0.621371).toFixed(1) + ' mph';
            return kmh.toFixed(1) + ' km/h';
        }

        // Overlay params helper (defined early for use in profile updates)
        function _buildOverlayParams() {
            let params = '';
            if (document.getElementById('overlay_speed')?.checked) params += '&overlay=speed';
            if (document.getElementById('overlay_grade')?.checked) params += '&overlay=grade';
            if (document.getElementById('overlay_gravel')?.checked) params += '&show_gravel=true';
            if (isImperial()) params += '&imperial=true';
            return params;
        }

        function renderClimbTable(climbs) {
            if (climbs.length === 0) {
                climbList.innerHTML = '<div class="no-climbs">No significant climbs detected</div>';
                climbCount.textContent = '(0)';
                return;
            }
            climbCount.textContent = '(' + climbs.length + ')';
            let html = '';
            climbs.forEach(climb => {
                html += `<div class="climb-row">
                    <div class="climb-number">${climb.climb_id}</div>
                    <div class="climb-details">
                        <div class="climb-name">${climb.label}</div>
                        <div class="climb-metrics">
                            <div class="climb-metric"><span class="metric-label">Distance</span><span class="metric-value">${formatDistance(climb.distance_m / 1000)}</span></div>
                            <div class="climb-metric"><span class="metric-label">Gain</span><span class="metric-value">${formatElevation(climb.elevation_gain)}</span></div>
                            <div class="climb-metric"><span class="metric-label">Avg Grade</span><span class="metric-value">${climb.avg_grade.toFixed(1)}%</span></div>
                            <div class="climb-metric"><span class="metric-label">Max Grade</span><span class="metric-value">${climb.max_grade.toFixed(1)}%</span></div>
                            <div class="climb-metric"><span class="metric-label">Duration</span><span class="metric-value">${formatClimbDuration(climb.duration_seconds)}</span></div>
                            <div class="climb-metric"><span class="metric-label">Work</span><span class="metric-value">${climb.work_kj.toFixed(0)} kJ</span></div>
                            <div class="climb-metric"><span class="metric-label">Avg Power</span><span class="metric-value">${climb.avg_power.toFixed(0)} W</span></div>
                            <div class="climb-metric"><span class="metric-label">Avg Speed</span><span class="metric-value">${formatSpeed(climb.avg_speed_kmh)}</span></div>
                        </div>
                    </div>
                </div>`;
            });
            climbList.innerHTML = html;
        }

        function updateClimbs(forceRefresh = false) {
            clearTimeout(debounceTimer);
            debounceTimer = setTimeout(() => {
                const sensitivity = slider.value;
                const aspect = getAspectRatio();
                // Only refresh image if aspect ratio changed significantly or forced
                if (forceRefresh || lastAspectRatio === null || Math.abs(aspect - lastAspectRatio) > 0.1) {
                    lastAspectRatio = aspect;
                    const climbLoading = document.getElementById('climbLoading');
                    if (climbLoading) climbLoading.classList.remove('hidden');
                    climbProfileImage.classList.add('loading');
                    climbProfileImage.src = `/elevation-profile-ride?url=${encodeURIComponent(routeUrl)}&${baseParams}&sensitivity=${sensitivity}&aspect=${aspect.toFixed(2)}`;
                    climbProfileImage.onload = () => {
                        climbProfileImage.classList.remove('loading');
                        if (climbLoading) climbLoading.classList.add('hidden');
                    };
                }
                fetch(`/api/detect-climbs?url=${encodeURIComponent(routeUrl)}&${baseParams}&sensitivity=${sensitivity}`)
                    .then(r => r.json())
                    .then(data => renderClimbTable(data.climbs))
                    .catch(err => console.error('Error fetching climbs:', err));
            }, 300);
        }
        slider.addEventListener('input', () => updateClimbs(true));

        // Update main elevation profile with current aspect ratio
        // Calculate aspect ratio for a specific container
        function getAspectForContainer(container) {
            if (!container) return 1;
            const width = container.offsetWidth;
            if (width < 500) return 1;
            if (width < 800) return 2;
            return Math.min(3.5, width / 250);
        }

        function updateMainProfile() {
            const container = document.getElementById('elevationContainer');
            const img = document.getElementById('elevationImg');
            const loading = document.getElementById('elevationLoading');
            if (!container || !img) return;
            const baseProfileUrl = container.getAttribute('data-base-profile-url');
            const baseDataUrl = container.getAttribute('data-base-data-url');
            if (!baseProfileUrl) return;
            const aspect = getAspectForContainer(container);  // Use this container's width
            const overlayParams = _buildOverlayParams();
            if (loading) loading.classList.remove('hidden');
            img.classList.add('loading');
            img.src = baseProfileUrl + `&aspect=${aspect.toFixed(2)}` + overlayParams;
            img.onload = () => {
                if (loading) loading.classList.add('hidden');
                img.classList.remove('loading');
                if (typeof setupElevationProfile === 'function' && baseDataUrl) {
                    setupElevationProfile('elevationContainer', 'elevationImg', 'elevationTooltip', 'elevationCursor', baseDataUrl);
                }
            };
        }

        // Handle window resize and orientation change
        function handleResize() {
            clearTimeout(resizeTimer);
            resizeTimer = setTimeout(() => {
                const newAspect = getAspectRatio();
                if (lastAspectRatio !== null && Math.abs(newAspect - lastAspectRatio) > 0.2) {
                    updateClimbs(true);
                    updateMainProfile();
                }
            }, 250);
        }
        window.addEventListener('resize', handleResize);
        window.addEventListener('orientationchange', () => setTimeout(handleResize, 100));

        // Initial load with correct aspect ratio
        document.addEventListener('DOMContentLoaded', () => {
            updateMainProfile();
            updateClimbs(true);
        });

        // Save sensitivity to localStorage when changed
        slider.addEventListener('change', () => {
            try { localStorage.setItem('ride_sensitivity', slider.value); } catch (e) {}
        });

        // Overlay toggles
        function toggleOverlay(type) {
            // Speed and grade are mutually exclusive (only one secondary Y-axis)
            if (type === 'speed' || type === 'grade') {
                const checkbox = document.getElementById('overlay_' + type);
                if (checkbox && checkbox.checked) {
                    const otherType = type === 'speed' ? 'grade' : 'speed';
                    const otherCheckbox = document.getElementById('overlay_' + otherType);
                    if (otherCheckbox && otherCheckbox.checked) {
                        otherCheckbox.checked = false;
                    }
                }
            }

            const container = document.getElementById('elevationContainer');
            const img = document.getElementById('elevationImg');
            const loading = document.getElementById('elevationLoading');
            if (!container || !img) return;
            const baseProfileUrl = container.getAttribute('data-base-profile-url');
            const baseDataUrl = container.getAttribute('data-base-data-url');
            if (!baseProfileUrl) return;
            const aspect = getAspectForContainer(container);  // Use this container's width
            const overlayParams = _buildOverlayParams();

            // Preserve zoom state from container data attributes
            let zoomParams = '';
            const zoomMin = container.getAttribute('data-zoom-min');
            const zoomMax = container.getAttribute('data-zoom-max');
            if (zoomMin && zoomMax) {
                zoomParams = `&min_xlim_hours=${zoomMin}&max_xlim_hours=${zoomMax}`;
            }

            if (loading) loading.classList.remove('hidden');
            img.classList.add('loading');
            img.src = baseProfileUrl + `&aspect=${aspect.toFixed(2)}` + overlayParams + zoomParams;
            img.onload = () => {
                if (loading) loading.classList.add('hidden');
                img.classList.remove('loading');
                if (typeof setupElevationProfile === 'function' && baseDataUrl) {
                    setupElevationProfile('elevationContainer', 'elevationImg', 'elevationTooltip', 'elevationCursor', baseDataUrl);
                }
            };
            // Save toggle states to localStorage
            try {
                localStorage.setItem('ride_show_speed', document.getElementById('overlay_speed')?.checked || false);
                localStorage.setItem('ride_show_grade', document.getElementById('overlay_grade')?.checked || false);
                localStorage.setItem('ride_show_gravel', document.getElementById('overlay_gravel')?.checked || false);
            } catch (e) {}
        }

        function updateSummaryUnits() {
            const distEl = document.getElementById('summaryDistance');
            const elevEl = document.getElementById('summaryElevation');
            if (distEl) {
                const km = parseFloat(distEl.dataset.km);
                distEl.textContent = formatDistance(km);
            }
            if (elevEl) {
                const m = parseFloat(elevEl.dataset.m);
                elevEl.textContent = formatElevation(m);
            }
        }

        function toggleImperial() {
            const imperial = isImperial();
            try { localStorage.setItem('ride_imperial', imperial); } catch (e) {}
            updateSummaryUnits();
            // Refresh elevation profile with new y-axis units
            refreshMainProfile();
            // Re-render climb table with new units
            updateClimbs();
        }

        function refreshMainProfile() {
            const container = document.getElementById('elevationContainer');
            const img = document.getElementById('elevationImg');
            const loading = document.getElementById('elevationLoading');
            if (!container || !img) return;
            const baseProfileUrl = container.getAttribute('data-base-profile-url');
            const baseDataUrl = container.getAttribute('data-base-data-url');
            if (!baseProfileUrl) return;
            const aspect = getAspectForContainer(container);  // Use this container's width
            const overlayParams = _buildOverlayParams();
            loading.classList.remove('hidden');
            img.classList.add('loading');
            img.src = baseProfileUrl + `&aspect=${aspect.toFixed(2)}` + overlayParams;
            img.onload = () => {
                loading.classList.add('hidden');
                img.classList.remove('loading');
                if (typeof setupElevationProfile === 'function' && baseDataUrl) {
                    setupElevationProfile('elevationContainer', 'elevationImg', 'elevationTooltip', 'elevationCursor', baseDataUrl);
                }
            };
        }

        function goBack() {
            let url = '/?url=' + encodeURIComponent(routeUrl) + '&' + baseParams;
            // Add settings from localStorage
            try {
                if (localStorage.getItem('overlay_speed') === 'true') url += '&overlay=speed';
                if (localStorage.getItem('overlay_grade') === 'true') url += '&overlay=grade';
                if (localStorage.getItem('overlay_gravel') === 'true') url += '&show_gravel=true';
                if (localStorage.getItem('ride_imperial') === 'true') url += '&imperial=1';
            } catch (e) {}
            window.location.href = url;
        }

        // Elevation profile interaction
        function setupElevationProfile(containerId, imgId, tooltipId, cursorId, dataUrl) {
            const container = document.getElementById(containerId);
            const img = document.getElementById(imgId);
            const tooltip = document.getElementById(tooltipId);
            const cursor = document.getElementById(cursorId);
            if (!container || !img || !tooltip || !cursor) return;

            const selection = document.getElementById('elevationSelection');
            const selectionPopup = document.getElementById('elevationSelectionPopup');

            let profileData = null;
            let selectionStart = null;
            let isSelecting = false;
            let selectionActive = false;

            // Zoom state - restore from container data attributes if present
            const savedZoomMin = container.getAttribute('data-zoom-min');
            const savedZoomMax = container.getAttribute('data-zoom-max');
            let isZoomed = !!(savedZoomMin && savedZoomMax);
            let zoomMinHours = savedZoomMin ? parseFloat(savedZoomMin) : null;
            let zoomMaxHours = savedZoomMax ? parseFloat(savedZoomMax) : null;
            let selectionStartTime = null;
            let selectionEndTime = null;
            const zoomOutLink = document.getElementById('zoomOutLink');

            // Clear any stale popup and selection from previous initialization
            if (selectionPopup) { selectionPopup.style.display = 'none'; selectionPopup.innerHTML = ''; }
            if (selection) selection.classList.remove('visible');

            // Show/hide zoom out link based on restored state
            if (zoomOutLink) {
                zoomOutLink.style.display = isZoomed ? 'block' : 'none';
                if (isZoomed) {
                    zoomOutLink.querySelector('a').onclick = function(e) {
                        e.preventDefault();
                        zoomOut();
                    };
                }
            }

            fetch(dataUrl)
                .then(r => {
                    if (!r.ok) { console.error('Profile data fetch failed:', r.status, dataUrl); return { error: 'HTTP ' + r.status }; }
                    return r.json();
                })
                .then(data => { if (data && !data.error) profileData = data; else if (data?.error) console.error('Profile data error:', data.error, dataUrl); })
                .catch(err => console.error('Profile data fetch exception:', err, dataUrl));

            // Calculate plot margins based on aspect ratio
            // Margins in inches are roughly constant, so as percentage they scale with 1/aspectRatio
            // Calibrated from figsize=(14,4) where leftMargin=0.7in, rightMargin=0.7in
            function getContainerAspect() {
                // Use THIS container's width, not the global getAspectRatio which uses climbProfileContainer
                const width = container.offsetWidth;
                if (width < 500) return 1;
                if (width < 800) return 2;
                return Math.min(3.5, width / 250);
            }
            function getPlotMargins() {
                const aspect = getContainerAspect();
                return {
                    left: 0.175 / aspect,   // 0.7in / (4in * aspect) = 0.175/aspect
                    right: 1 - 0.175 / aspect  // 1 - 0.7in / (4in * aspect) = 1 - 0.175/aspect
                };
            }
            let plotMargins = getPlotMargins();
            function getPlotLeftPct() { return plotMargins.left; }
            function getPlotRightPct() { return plotMargins.right; }
            function updatePlotMargins() { plotMargins = getPlotMargins(); }

            function getDataAtPosition(xPct) {
                if (!profileData || !profileData.times || profileData.times.length < 2) return null;
                const leftPct = getPlotLeftPct(), rightPct = getPlotRightPct();
                const plotXPct = (xPct - leftPct) / (rightPct - leftPct);
                if (plotXPct < 0 || plotXPct > 1) return null;
                // Use zoom bounds if zoomed, otherwise full range
                const minTime = isZoomed ? zoomMinHours : 0;
                const maxTime = isZoomed ? zoomMaxHours : profileData.total_time;
                const time = minTime + plotXPct * (maxTime - minTime);
                if (time > profileData.total_time || time < 0) return null;
                for (let i = 0; i < profileData.times.length - 1; i++) {
                    if (time >= profileData.times[i] && time < profileData.times[i + 1]) {
                        return { grade: profileData.grades[i], elevation: profileData.elevations[i] || 0, speed: profileData.speeds ? profileData.speeds[i] : null, time: time };
                    }
                }
                const lastIdx = profileData.grades.length - 1;
                return { grade: profileData.grades[lastIdx], elevation: profileData.elevations[lastIdx + 1] || 0, speed: profileData.speeds ? profileData.speeds[lastIdx] : null, time: time };
            }

            function getIndexAtPosition(xPct) {
                if (!profileData || !profileData.times || profileData.times.length < 2) return -1;
                const leftPct = getPlotLeftPct(), rightPct = getPlotRightPct();
                const plotXPct = Math.max(0, Math.min(1, (xPct - leftPct) / (rightPct - leftPct)));
                // Use zoom bounds if zoomed
                const minTime = isZoomed ? zoomMinHours : 0;
                const maxTime = isZoomed ? zoomMaxHours : profileData.total_time;
                const time = Math.max(0, Math.min(minTime + plotXPct * (maxTime - minTime), profileData.total_time));
                for (let i = 0; i < profileData.times.length - 1; i++) {
                    if (time >= profileData.times[i] && time < profileData.times[i + 1]) return i;
                }
                return profileData.times.length - 2;
            }

            // Convert time to index (for selection repositioning after zoom)
            function getIndexAtTime(time) {
                if (!profileData || !profileData.times || profileData.times.length < 2) return -1;
                for (let i = 0; i < profileData.times.length - 1; i++) {
                    if (time >= profileData.times[i] && time < profileData.times[i + 1]) return i;
                }
                return profileData.times.length - 2;
            }

            function formatGrade(g) {
                if (g === null || g === undefined) return 'Stopped';
                return (g >= 0 ? '+' : '') + g.toFixed(1) + '%';
            }

            function formatTime(hours) {
                const h = Math.floor(hours);
                const m = Math.floor((hours - h) * 60);
                return h + 'h ' + m.toString().padStart(2, '0') + 'm';
            }

            function formatDuration(hours) {
                const totalMin = Math.round(hours * 60);
                if (totalMin < 60) return totalMin + 'min';
                return Math.floor(totalMin / 60) + 'h ' + (totalMin % 60).toString().padStart(2, '0') + 'm';
            }

            function updateTooltip(xPct, clientX) {
                const data = getDataAtPosition(xPct);
                if (data) {
                    tooltip.querySelector('.grade').textContent = formatGrade(data.grade);
                    const imp = isImperial();
                    const elevUnit = imp ? 'ft' : 'm';
                    const elevVal = imp ? data.elevation * 3.28084 : data.elevation;
                    let speedText = '';
                    if (data.speed !== null && data.speed !== undefined) {
                        const speedUnit = imp ? 'mph' : 'km/h';
                        const speedVal = imp ? data.speed * 0.621371 : data.speed;
                        speedText = ' | ' + speedVal.toFixed(1) + ' ' + speedUnit;
                    }
                    tooltip.querySelector('.elev').textContent = Math.round(elevVal) + ' ' + elevUnit + speedText + ' | ' + formatTime(data.time);
                    const rect = img.getBoundingClientRect();
                    const xPos = clientX - rect.left;
                    tooltip.style.left = xPos + 'px';
                    tooltip.style.bottom = '60px';
                    tooltip.classList.add('visible');
                    cursor.style.left = xPos + 'px';
                    cursor.classList.add('visible');
                } else {
                    hideTooltip();
                }
            }

            function hideTooltip() {
                tooltip.classList.remove('visible');
                cursor.classList.remove('visible');
            }

            function updateSelectionHighlight(startXPct, endXPct) {
                if (!selection) return;
                const leftPct = getPlotLeftPct(), rightPct = getPlotRightPct();
                const clampedStart = Math.max(leftPct, Math.min(rightPct, startXPct));
                const clampedEnd = Math.max(leftPct, Math.min(rightPct, endXPct));
                selection.style.left = (Math.min(clampedStart, clampedEnd) * 100) + '%';
                selection.style.width = (Math.abs(clampedEnd - clampedStart) * 100) + '%';
                selection.classList.add('visible');
            }

            function computeSelectionStats(startIdx, endIdx) {
                if (!profileData) return null;
                const d = profileData;
                const i = Math.min(startIdx, endIdx), j = Math.max(startIdx, endIdx);
                if (i < 0 || j >= d.times.length) return null;
                const duration = d.times[j + 1 < d.times.length ? j + 1 : j] - d.times[i];
                let distM = 0;
                if (d.distances) for (let k = i; k <= j; k++) distM += (d.distances[k] || 0);
                let elevGain = 0, elevLoss = 0;
                if (d.elev_gains && d.elev_losses) {
                    for (let k = i; k <= j; k++) { elevGain += (d.elev_gains[k] || 0); elevLoss += (d.elev_losses[k] || 0); }
                } else {
                    for (let k = i; k <= j; k++) {
                        const diff = (d.elevations[k + 1] !== undefined ? d.elevations[k + 1] : d.elevations[k]) - d.elevations[k];
                        if (diff > 0) elevGain += diff; else elevLoss += diff;
                    }
                }
                let gradeSum = 0, gradeCount = 0;
                for (let k = i; k <= j; k++) if (d.grades[k] !== null && d.grades[k] !== undefined) { gradeSum += d.grades[k]; gradeCount++; }
                const avgGrade = gradeCount > 0 ? gradeSum / gradeCount : null;
                const avgSpeed = (duration > 0 && distM > 0) ? (distM / 1000) / duration : null;
                let workJ = 0;
                // Use pre-computed works array (accurate through downsampling) if available
                if (d.works) {
                    for (let k = i; k <= j; k++) { workJ += (d.works[k] || 0); }
                } else if (d.powers) {
                    for (let k = i; k <= j; k++) {
                        if (d.powers[k] !== null && d.powers[k] !== undefined) {
                            workJ += d.powers[k] * ((d.times[k + 1 < d.times.length ? k + 1 : k] - d.times[k]) * 3600);
                        }
                    }
                }
                // Avg power = work / time (matches summary calculation)
                const durationSec = duration * 3600;
                const avgPower = (workJ > 0 && durationSec > 0) ? workJ / durationSec : null;
                return { duration, distKm: distM / 1000, elevGain, elevLoss, avgGrade, avgSpeed, avgPower, workKJ: workJ / 1000 };
            }

            function showSelectionPopup(stats, xPctCenter) {
                if (!selectionPopup || !stats) return;
                const imp = isImperial();
                const distVal = imp ? (stats.distKm * 0.621371) : stats.distKm;
                const distUnit = imp ? 'mi' : 'km';
                const elevGainVal = imp ? (stats.elevGain * 3.28084) : stats.elevGain;
                const elevLossVal = imp ? (stats.elevLoss * 3.28084) : stats.elevLoss;
                const elevUnit = imp ? 'ft' : 'm';
                const speedVal = stats.avgSpeed !== null ? (imp ? stats.avgSpeed * 0.621371 : stats.avgSpeed) : null;
                const speedUnit = imp ? 'mph' : 'km/h';

                let html = '<span class="selection-close">&times;</span>';
                html += '<div class="selection-stat"><span class="stat-label">Duration</span><span class="stat-value">' + formatDuration(stats.duration) + '</span></div>';
                html += '<div class="selection-stat"><span class="stat-label">Distance</span><span class="stat-value">' + distVal.toFixed(1) + ' ' + distUnit + '</span></div>';
                html += '<div class="selection-stat"><span class="stat-label">Elev Gain</span><span class="stat-value">+' + Math.round(elevGainVal) + ' ' + elevUnit + '</span></div>';
                html += '<div class="selection-stat"><span class="stat-label">Elev Loss</span><span class="stat-value">' + Math.round(elevLossVal) + ' ' + elevUnit + '</span></div>';
                if (stats.avgGrade !== null) html += '<div class="selection-stat"><span class="stat-label">Avg Grade</span><span class="stat-value">' + formatGrade(stats.avgGrade) + '</span></div>';
                if (speedVal !== null) html += '<div class="selection-stat"><span class="stat-label">Avg Speed</span><span class="stat-value">' + speedVal.toFixed(1) + ' ' + speedUnit + '</span></div>';
                if (stats.avgPower !== null) {
                    html += '<div class="selection-stat"><span class="stat-label">Avg Power</span><span class="stat-value">' + Math.round(stats.avgPower) + ' W</span></div>';
                    html += '<div class="selection-stat"><span class="stat-label">Work</span><span class="stat-value">' + stats.workKJ.toFixed(1) + ' kJ</span></div>';
                }
                // Add zoom button
                html += '<div class="selection-zoom-btn">' + (isZoomed ? 'Zoom Out' : 'Zoom In') + '</div>';
                selectionPopup.innerHTML = html;
                selectionPopup.style.display = 'block';
                selectionPopup.style.left = (xPctCenter * 100) + '%';
                selectionPopup.style.bottom = '70px';
                selectionActive = true;
                selectionPopup.querySelector('.selection-close')?.addEventListener('click', (ev) => { ev.stopPropagation(); clearSelection(); });
                // Zoom button handler
                var zoomBtn = selectionPopup.querySelector('.selection-zoom-btn');
                if (zoomBtn) {
                    zoomBtn.addEventListener('click', function(ev) {
                        ev.stopPropagation();
                        if (isZoomed) {
                            zoomOut();
                        } else {
                            zoomIn();
                        }
                    });
                }
            }

            function clearSelection() {
                if (selection) selection.classList.remove('visible');
                if (selectionPopup) { selectionPopup.style.display = 'none'; selectionPopup.innerHTML = ''; }
                selectionStart = null; isSelecting = false; selectionActive = false;
            }

            function zoomIn() {
                if (!profileData || !selection) return;

                // Get selection bounds in pixel percentages
                const selLeft = parseFloat(selection.style.left) / 100;
                const selWidth = parseFloat(selection.style.width) / 100;

                // Convert to time using current zoom state
                const leftPct = getPlotLeftPct(), rightPct = getPlotRightPct();
                const plotRange = rightPct - leftPct;
                const minTime = isZoomed ? zoomMinHours : 0;
                const maxTime = isZoomed ? zoomMaxHours : profileData.total_time;
                const viewRange = maxTime - minTime;

                const startPct = (selLeft - leftPct) / plotRange;
                const endPct = (selLeft + selWidth - leftPct) / plotRange;

                selectionStartTime = minTime + startPct * viewRange;
                selectionEndTime = minTime + endPct * viewRange;

                // Calculate zoom bounds with padding so selection takes 90% of view
                const selectionDuration = selectionEndTime - selectionStartTime;
                const totalZoomRange = selectionDuration / 0.9;
                const padding = (totalZoomRange - selectionDuration) / 2;

                zoomMinHours = Math.max(0, selectionStartTime - padding);
                zoomMaxHours = Math.min(profileData.total_time, selectionEndTime + padding);

                // Store zoom state on container for persistence across overlay toggles
                container.setAttribute('data-zoom-min', zoomMinHours.toFixed(4));
                container.setAttribute('data-zoom-max', zoomMaxHours.toFixed(4));

                isZoomed = true;
                refreshZoomedProfile();
            }

            function zoomOut() {
                isZoomed = false;
                zoomMinHours = null;
                zoomMaxHours = null;
                selectionStartTime = null;
                selectionEndTime = null;

                // Clear zoom state from container
                container.removeAttribute('data-zoom-min');
                container.removeAttribute('data-zoom-max');

                clearSelection();
                refreshZoomedProfile();
            }

            function refreshZoomedProfile() {
                var baseProfileUrl = container.getAttribute('data-base-profile-url');
                var loading = document.getElementById('elevationLoading');

                if (!baseProfileUrl) return;

                // Build URL parameters
                var params = '';
                var aspect = getContainerAspect();
                params += '&aspect=' + aspect.toFixed(2);

                // Add overlay parameters (must match _buildOverlayParams format)
                if (document.getElementById('overlay_speed')?.checked) params += '&overlay=speed';
                if (document.getElementById('overlay_grade')?.checked) params += '&overlay=grade';
                if (document.getElementById('overlay_gravel')?.checked) params += '&show_gravel=true';
                if (isImperial()) params += '&imperial=true';

                // Add zoom parameters
                if (isZoomed && zoomMinHours !== null && zoomMaxHours !== null) {
                    params += '&min_xlim_hours=' + zoomMinHours.toFixed(4);
                    params += '&max_xlim_hours=' + zoomMaxHours.toFixed(4);
                }

                // Show loading spinner
                if (loading) loading.classList.remove('hidden');
                img.classList.add('loading');

                // Update image
                img.src = baseProfileUrl + params;

                img.onload = function() {
                    if (loading) loading.classList.add('hidden');
                    img.classList.remove('loading');
                    updatePlotMargins();

                    // Show/hide zoom out link
                    if (zoomOutLink) {
                        zoomOutLink.style.display = isZoomed ? 'block' : 'none';
                        if (isZoomed) {
                            zoomOutLink.querySelector('a').onclick = function(e) {
                                e.preventDefault();
                                zoomOut();
                            };
                        }
                    }

                    // Reposition selection if zoomed
                    if (isZoomed && selectionStartTime !== null && selectionEndTime !== null) {
                        repositionSelectionAfterZoom();
                    }
                };
            }

            function repositionSelectionAfterZoom() {
                if (!selection || !isZoomed || selectionStartTime === null || selectionEndTime === null) return;

                // Calculate the new position of selection in zoomed view
                const zoomRange = zoomMaxHours - zoomMinHours;
                const leftPct = getPlotLeftPct(), rightPct = getPlotRightPct();
                const plotRange = rightPct - leftPct;

                // Convert time to plot percentage
                const startPct = leftPct + ((selectionStartTime - zoomMinHours) / zoomRange) * plotRange;
                const endPct = leftPct + ((selectionEndTime - zoomMinHours) / zoomRange) * plotRange;

                // Clamp to plot boundaries
                const clampedStart = Math.max(leftPct, Math.min(rightPct, startPct));
                const clampedEnd = Math.max(leftPct, Math.min(rightPct, endPct));

                selection.style.left = (Math.min(clampedStart, clampedEnd) * 100) + '%';
                selection.style.width = (Math.abs(clampedEnd - clampedStart) * 100) + '%';
                selection.classList.add('visible');

                // Re-show popup with Zoom Out button
                const centerXPct = (clampedStart + clampedEnd) / 2;
                const startIdx = getIndexAtTime(selectionStartTime);
                const endIdx = getIndexAtTime(selectionEndTime);
                const stats = computeSelectionStats(startIdx, endIdx);
                if (stats) {
                    showSelectionPopup(stats, centerXPct);
                }
            }

            function onMouseMove(e) {
                if (!profileData) return;
                const rect = img.getBoundingClientRect();
                const xPct = (e.clientX - rect.left) / rect.width;
                if (isSelecting) { updateSelectionHighlight(selectionStart, xPct); updateTooltip(xPct, e.clientX); }
                else if (!selectionActive) updateTooltip(xPct, e.clientX);
            }

            function onMouseDown(e) {
                if (!profileData) return;
                // If popup is showing and click is outside popup, dismiss popup but keep selection if zoomed
                if (selectionActive) {
                    // Don't dismiss if clicking inside the popup
                    if (selectionPopup && selectionPopup.contains(e.target)) {
                        return;
                    }
                    if (selectionPopup) {
                        selectionPopup.style.display = 'none';
                        selectionPopup.innerHTML = '';
                    }
                    selectionActive = false;
                    // Keep selection visible if zoomed
                    if (!isZoomed && selection) {
                        selection.classList.remove('visible');
                    }
                    return;
                }
                const rect = img.getBoundingClientRect();
                selectionStart = (e.clientX - rect.left) / rect.width;
                isSelecting = true;
                e.preventDefault();
            }

            function onMouseUp(e) {
                if (!isSelecting) return;
                isSelecting = false;
                const rect = img.getBoundingClientRect();
                const xPctEnd = (e.clientX - rect.left) / rect.width;
                const dragPx = Math.abs(e.clientX - rect.left - selectionStart * rect.width);
                if (dragPx > 5) {
                    const startIdx = getIndexAtPosition(selectionStart);
                    const endIdx = getIndexAtPosition(xPctEnd);
                    if (startIdx >= 0 && endIdx >= 0 && startIdx !== endIdx) {
                        const stats = computeSelectionStats(startIdx, endIdx);
                        hideTooltip();
                        showSelectionPopup(stats, (selectionStart + xPctEnd) / 2);
                    } else clearSelection();
                } else clearSelection();
            }

            function onMouseLeave(e) { if (isSelecting) onMouseUp(e); hideTooltip(); }

            // Long-press touch selection
            const LONG_PRESS_DURATION = 400;  // ms to trigger long-press
            const LONG_PRESS_MOVE_THRESHOLD = 15;  // px movement allowed during long-press wait
            let longPressTimer = null;
            let longPressStartX = 0;
            let longPressStartY = 0;
            let longPressPending = false;

            // Create long-press indicator element
            let longPressIndicator = container.querySelector('.long-press-indicator');
            if (!longPressIndicator) {
                longPressIndicator = document.createElement('div');
                longPressIndicator.className = 'long-press-indicator';
                longPressIndicator.innerHTML = '<div class="long-press-ring"></div>';
                container.appendChild(longPressIndicator);
            }

            function showLongPressIndicator(clientX, clientY) {
                const rect = container.getBoundingClientRect();
                longPressIndicator.style.left = (clientX - rect.left) + 'px';
                longPressIndicator.style.top = (clientY - rect.top) + 'px';
                longPressIndicator.classList.add('active');
            }

            function hideLongPressIndicator() {
                longPressIndicator.classList.remove('active');
            }

            function triggerHapticFeedback() {
                if (navigator.vibrate) {
                    navigator.vibrate(50);
                }
            }

            function cancelLongPress() {
                if (longPressTimer) {
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                }
                longPressPending = false;
                hideLongPressIndicator();
            }

            function onTouchStart(e) {
                if (!profileData) return;
                // If popup is showing, check if tap is inside popup
                if (selectionActive) {
                    // Don't dismiss if tapping inside the popup
                    if (selectionPopup && e.touches[0] && selectionPopup.contains(document.elementFromPoint(e.touches[0].clientX, e.touches[0].clientY))) {
                        return;
                    }
                    if (selectionPopup) {
                        selectionPopup.style.display = 'none';
                        selectionPopup.innerHTML = '';
                    }
                    selectionActive = false;
                    // Keep selection visible if zoomed
                    if (!isZoomed && selection) {
                        selection.classList.remove('visible');
                    }
                    return;
                }

                const touch = e.touches[0];
                longPressStartX = touch.clientX;
                longPressStartY = touch.clientY;
                longPressPending = true;

                // Show visual indicator immediately
                showLongPressIndicator(touch.clientX, touch.clientY);

                // Start long-press timer
                longPressTimer = setTimeout(() => {
                    if (!longPressPending) return;
                    longPressPending = false;
                    hideLongPressIndicator();

                    // Trigger haptic feedback
                    triggerHapticFeedback();

                    // Enter selection mode
                    const rect = img.getBoundingClientRect();
                    selectionStart = (touch.clientX - rect.left) / rect.width;
                    isSelecting = true;

                    // Show initial selection highlight at touch point
                    updateSelectionHighlight(selectionStart, selectionStart);
                }, LONG_PRESS_DURATION);
            }

            function onTouchMove(e) {
                if (!profileData) return;

                const touch = e.touches[0];

                // If waiting for long-press, check if moved too much
                if (longPressPending) {
                    const dx = touch.clientX - longPressStartX;
                    const dy = touch.clientY - longPressStartY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance > LONG_PRESS_MOVE_THRESHOLD) {
                        // User is scrolling, cancel long-press
                        cancelLongPress();
                        return;
                    }
                    // Still waiting for long-press, don't prevent default (allow scroll)
                    return;
                }

                // In selection mode - prevent scrolling and update selection
                if (isSelecting) {
                    e.preventDefault();
                    const rect = img.getBoundingClientRect();
                    const xPct = (touch.clientX - rect.left) / rect.width;
                    updateSelectionHighlight(selectionStart, xPct);
                    updateTooltip(xPct, touch.clientX);
                }
            }

            function onTouchEnd(e) {
                // Cancel any pending long-press
                if (longPressPending) {
                    cancelLongPress();
                    hideTooltip();
                    return;
                }

                if (!isSelecting) { hideTooltip(); return; }
                isSelecting = false;
                if (!selection) { hideTooltip(); return; }

                const rect = img.getBoundingClientRect();
                const selLeft = parseFloat(selection.style.left) / 100;
                const selWidth = parseFloat(selection.style.width) / 100;
                if (selWidth * rect.width > 30) {
                    const startIdx = getIndexAtPosition(selLeft);
                    const endIdx = getIndexAtPosition(selLeft + selWidth);
                    if (startIdx >= 0 && endIdx >= 0 && startIdx !== endIdx) {
                        const stats = computeSelectionStats(startIdx, endIdx);
                        hideTooltip();
                        showSelectionPopup(stats, selLeft + selWidth / 2);
                    } else clearSelection();
                } else clearSelection();
                hideTooltip();
            }

            function onTouchCancel(e) {
                cancelLongPress();
                if (isSelecting) {
                    isSelecting = false;
                    clearSelection();
                }
                hideTooltip();
            }

            if (container._profileCleanup) container._profileCleanup();
            const ac = new AbortController();
            container.addEventListener('mousemove', onMouseMove, { signal: ac.signal });
            container.addEventListener('mousedown', onMouseDown, { signal: ac.signal });
            container.addEventListener('mouseup', onMouseUp, { signal: ac.signal });
            container.addEventListener('mouseleave', onMouseLeave, { signal: ac.signal });
            container.addEventListener('touchstart', onTouchStart, { passive: true, signal: ac.signal });
            container.addEventListener('touchmove', onTouchMove, { passive: false, signal: ac.signal });
            container.addEventListener('touchend', onTouchEnd, { passive: true, signal: ac.signal });
            container.addEventListener('touchcancel', onTouchCancel, { passive: true, signal: ac.signal });
            document.addEventListener('keydown', (e) => { if (e.key === 'Escape') clearSelection(); }, { signal: ac.signal });
            container._profileCleanup = () => ac.abort();
        }

        // Initialize elevation profile
        const container = document.getElementById('elevationContainer');
        const dataUrl = container?.getAttribute('data-base-data-url');
        if (dataUrl) setupElevationProfile('elevationContainer', 'elevationImg', 'elevationTooltip', 'elevationCursor', dataUrl);

        // Load saved settings from localStorage
        function initSavedSettings() {
            try {
                // Load speed toggle
                const savedSpeed = localStorage.getItem('ride_show_speed');
                if (savedSpeed === 'true') {
                    const speedCb = document.getElementById('overlay_speed');
                    if (speedCb) speedCb.checked = true;
                }
                // Load gravel toggle
                const savedGravel = localStorage.getItem('ride_show_gravel');
                if (savedGravel === 'true') {
                    const gravelCb = document.getElementById('overlay_gravel');
                    if (gravelCb) gravelCb.checked = true;
                }
                // Load imperial setting (check ride_imperial first, fall back to main page's setting)
                const savedImperial = localStorage.getItem('ride_imperial');
                const imperialCb = document.getElementById('imperial');
                if (savedImperial !== null && imperialCb) {
                    imperialCb.checked = savedImperial === 'true';
                }
                // Load sensitivity slider
                const savedSensitivity = localStorage.getItem('ride_sensitivity');
                if (savedSensitivity !== null) {
                    const sensitivityVal = parseInt(savedSensitivity, 10);
                    if (!isNaN(sensitivityVal) && sensitivityVal >= 0 && sensitivityVal <= 100) {
                        slider.value = sensitivityVal;
                    }
                }
                // If any toggles were restored, update the profile image
                const speedCb = document.getElementById('overlay_speed');
                const gravelCb = document.getElementById('overlay_gravel');
                if ((speedCb?.checked) || (gravelCb?.checked)) {
                    toggleOverlay(null);
                }
                // If sensitivity was restored and differs from default, update climbs
                const savedSens = localStorage.getItem('ride_sensitivity');
                if (savedSens !== null && parseInt(savedSens, 10) !== {{ sensitivity }}) {
                    updateClimbs();
                }
                // Update units based on imperial setting
                updateSummaryUnits();
            } catch (e) {}
        }
        initSavedSettings();
    </script>

    <div class="footer">
        <div class="footer-content">
            <div class="footer-links">
                <a href="https://github.com/sanmi/gpx-analyzer" target="_blank">Source Code</a>
                <a href="https://github.com/sanmi/gpx-analyzer/issues" target="_blank">Report a Bug</a>
            </div>
            <div class="footer-version">{{ version_date }} ({{ git_hash }})</div>
            <div class="footer-copyright"> 2025 Frank San Miguel</div>
        </div>
    </div>
    {% if umami_website_id and route_name %}
    <script>
        // Track ride page view with Umami (wait for script to load)
        window.addEventListener('load', function() {
            if (typeof umami !== 'undefined') {
                umami.track('ride-view', {
                    distance_km: {{ "%.1f"|format(distance_km) if distance_km else 0 }},
                    elevation_m: {{ "%.0f"|format(elevation_m) if elevation_m else 0 }},
                    climbs: {{ climbs|length if climbs else 0 }},
                    name: '{{ route_name|replace("'", "\\'") if route_name else "" }}'
                });
            }
        });
    </script>
    {% endif %}
</body>
</html>
